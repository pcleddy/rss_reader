<!DOCTYPE html>
<!-- RSS Reader v0.2.0 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSS Reader v0.2.0</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        h1 { margin-bottom: 10px; }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #f0f0f0; }
        button.primary { background: #0066cc; color: #fff; border-color: #0066cc; }
        button.primary:hover { background: #0055aa; }
        button.small { padding: 4px 10px; font-size: 12px; }
        input[type="text"], input[type="url"] {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            flex: 1;
            min-width: 200px;
        }
        .feeds-list {
            margin-bottom: 20px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .feeds-list h2 { margin-top: 0; font-size: 16px; }
        .feed-tag {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background: #e8f4ff;
            border-radius: 4px;
            margin: 3px;
            font-size: 13px;
        }
        .feed-tag button {
            padding: 2px 6px;
            font-size: 11px;
            background: #ff6b6b;
            color: #fff;
            border: none;
        }
        .items-container {
            background: #fff;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .item {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }
        .item:last-child { border-bottom: none; }
        .item.read { opacity: 0.6; }
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }
        .item-title {
            font-weight: 600;
            color: #0066cc;
            text-decoration: none;
            font-size: 15px;
        }
        .item-title:hover { text-decoration: underline; }
        .item.read .item-title { color: #666; }
        .item-meta {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .item-desc {
            font-size: 14px;
            color: #555;
            margin-top: 8px;
            line-height: 1.5;
        }
        .mark-read-btn {
            font-size: 11px;
            padding: 3px 8px;
            white-space: nowrap;
        }
        .status {
            padding: 10px 15px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 14px;
        }
        .status.loading { background: #fff3cd; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.success { background: #d4edda; color: #155724; }
        .hidden { display: none; }
        .stats {
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stats label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        input[type="file"] { display: none; }

        /* Suggestions sidebar */
        .suggestions-panel {
            margin-bottom: 20px;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #ddd;
            overflow: hidden;
        }
        .suggestions-header {
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .suggestions-header h2 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }
        .suggestions-header:hover { background: #f0f1f2; }
        .suggestions-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .suggestions-content.open {
            max-height: 600px;
            overflow-y: auto;
        }
        .suggestions-category {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
        }
        .suggestions-category:last-child { border-bottom: none; }
        .suggestions-category h3 {
            font-size: 12px;
            color: #666;
            margin: 0 0 8px 0;
            text-transform: uppercase;
        }
        .suggestion-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            margin: 2px;
            background: #f0f7ff;
            border: 1px solid #d0e3f7;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        .suggestion-item:hover {
            background: #e0efff;
            border-color: #0066cc;
        }
        .suggestion-item.added {
            background: #e8f5e9;
            border-color: #a5d6a7;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <h1>ðŸ“° RSS Reader</h1>
    <p style="color: #666; margin-bottom: 20px;">Import your state file to continue where you left off, or add feeds to get started.</p>

    <div class="controls">
        <input type="url" id="feedUrl" placeholder="Enter RSS feed URL...">
        <button class="primary" onclick="addFeed()">Add Feed</button>
        <button onclick="refreshAll()">ðŸ”„ Refresh All</button>
        <button onclick="document.getElementById('importFile').click()">ðŸ“¥ Import State</button>
        <button onclick="exportState()">ðŸ“¤ Export State</button>
        <button onclick="markAllRead()">âœ“ Mark All Read</button>
        <input type="file" id="importFile" accept=".json" onchange="importState(event)">
    </div>

    <!-- Suggestions Panel -->
    <div class="suggestions-panel">
        <div class="suggestions-header" onclick="toggleSuggestions()">
            <h2>ðŸ“š Discover Feeds</h2>
            <span id="suggestionsToggle">â–¶ Show</span>
        </div>
        <div class="suggestions-content" id="suggestionsContent"></div>
    </div>

    <div class="feeds-list">
        <h2>Subscriptions</h2>
        <div id="feedsList">No feeds yet. Add one above or import a state file.</div>
    </div>

    <div id="status" class="status hidden"></div>

    <div class="stats" id="stats">
        <span id="statsText"></span>
        <label>
            <input type="checkbox" id="showReadToggle" onchange="renderItems()">
            Show read items
        </label>
    </div>

    <div class="items-container" id="itemsContainer">
        <div class="item" style="color: #888; text-align: center;">
            Add feeds and click "Refresh All" to load articles.
        </div>
    </div>

    <script>
        // State structure
        let state = {
            feeds: [],      // { url, title }
            readItems: [],  // array of item links/guids that have been read
            lastUpdated: null
        };

        let allItems = []; // Current session's fetched items

        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

        // Feed suggestions by category
        const FEED_SUGGESTIONS = {
            "Tech News": [
                { name: "Hacker News", url: "https://hnrss.org/frontpage" },
                { name: "Ars Technica", url: "https://feeds.arstechnica.com/arstechnica/index" },
                { name: "The Verge", url: "https://www.theverge.com/rss/index.xml" },
                { name: "TechCrunch", url: "https://techcrunch.com/feed/" },
                { name: "Wired", url: "https://www.wired.com/feed/rss" },
                { name: "MIT Tech Review", url: "https://www.technologyreview.com/feed/" },
                { name: "Engadget", url: "https://www.engadget.com/rss.xml" },
                { name: "Gizmodo", url: "https://gizmodo.com/rss" },
                { name: "AnandTech", url: "https://www.anandtech.com/rss/" },
                { name: "Tom's Hardware", url: "https://www.tomshardware.com/feeds/all" },
            ],
            "AI & ML": [
                { name: "Anthropic Blog", url: "https://blog.anthropic.com/rss.xml" },
                { name: "OpenAI Blog", url: "https://openai.com/blog/rss.xml" },
                { name: "Google AI Blog", url: "https://blog.google/technology/ai/rss/" },
                { name: "DeepMind", url: "https://deepmind.google/blog/rss.xml" },
                { name: "Hugging Face Blog", url: "https://huggingface.co/blog/feed.xml" },
                { name: "ML Mastery", url: "https://machinelearningmastery.com/feed/" },
                { name: "Towards Data Science", url: "https://towardsdatascience.com/feed" },
                { name: "Papers With Code", url: "https://paperswithcode.com/rss" },
            ],
            "Programming": [
                { name: "Simon Willison", url: "https://simonwillison.net/atom/everything/" },
                { name: "Joel on Software", url: "https://www.joelonsoftware.com/feed/" },
                { name: "Coding Horror", url: "https://blog.codinghorror.com/rss/" },
                { name: "CSS-Tricks", url: "https://css-tricks.com/feed/" },
                { name: "Smashing Magazine", url: "https://www.smashingmagazine.com/feed/" },
                { name: "A List Apart", url: "https://alistapart.com/main/feed/" },
                { name: "Dev.to", url: "https://dev.to/feed" },
                { name: "Lobsters", url: "https://lobste.rs/rss" },
                { name: "The Pragmatic Engineer", url: "https://newsletter.pragmaticengineer.com/feed" },
                { name: "Martin Fowler", url: "https://martinfowler.com/feed.atom" },
                { name: "Dan Abramov", url: "https://overreacted.io/rss.xml" },
                { name: "Julia Evans", url: "https://jvns.ca/atom.xml" },
                { name: "Daring Fireball", url: "https://daringfireball.net/feeds/main" },
            ],
            "Science": [
                { name: "Nature", url: "https://www.nature.com/nature.rss" },
                { name: "Science Daily", url: "https://www.sciencedaily.com/rss/all.xml" },
                { name: "Quanta Magazine", url: "https://api.quantamagazine.org/feed/" },
                { name: "New Scientist", url: "https://www.newscientist.com/feed/home/" },
                { name: "Scientific American", url: "https://rss.sciam.com/ScientificAmerican-Global" },
                { name: "Phys.org", url: "https://phys.org/rss-feed/" },
                { name: "NASA", url: "https://www.nasa.gov/rss/dyn/breaking_news.rss" },
                { name: "Space.com", url: "https://www.space.com/feeds/all" },
            ],
            "News": [
                { name: "Reuters", url: "https://www.reutersagency.com/feed/" },
                { name: "AP News", url: "https://apnews.com/index.rss" },
                { name: "NPR", url: "https://feeds.npr.org/1001/rss.xml" },
                { name: "BBC", url: "https://feeds.bbci.co.uk/news/rss.xml" },
                { name: "The Guardian", url: "https://www.theguardian.com/world/rss" },
                { name: "Al Jazeera", url: "https://www.aljazeera.com/xml/rss/all.xml" },
                { name: "The Atlantic", url: "https://www.theatlantic.com/feed/all/" },
                { name: "Vox", url: "https://www.vox.com/rss/index.xml" },
            ],
            "Business & Finance": [
                { name: "Bloomberg", url: "https://feeds.bloomberg.com/markets/news.rss" },
                { name: "Financial Times", url: "https://www.ft.com/rss/home" },
                { name: "The Economist", url: "https://www.economist.com/rss" },
                { name: "Harvard Business Review", url: "https://hbr.org/rss" },
                { name: "Y Combinator", url: "https://www.ycombinator.com/blog/rss/" },
                { name: "a]6z", url: "https://a16z.com/feed/" },
                { name: "Stratechery", url: "https://stratechery.com/feed/" },
            ],
            "Design": [
                { name: "Designer News", url: "https://www.designernews.co/?format=rss" },
                { name: "UX Collective", url: "https://uxdesign.cc/feed" },
                { name: "NN Group", url: "https://www.nngroup.com/feed/rss/" },
                { name: "Sidebar", url: "https://sidebar.io/feed.xml" },
                { name: "Codrops", url: "https://tympanus.net/codrops/feed/" },
            ],
            "Security": [
                { name: "Krebs on Security", url: "https://krebsonsecurity.com/feed/" },
                { name: "Schneier on Security", url: "https://www.schneier.com/feed/" },
                { name: "The Hacker News", url: "https://feeds.feedburner.com/TheHackersNews" },
                { name: "Dark Reading", url: "https://www.darkreading.com/rss.xml" },
                { name: "Troy Hunt", url: "https://www.troyhunt.com/rss/" },
            ],
            "Podcasts": [
                { name: "Lex Fridman", url: "https://lexfridman.com/feed/podcast/" },
                { name: "Changelog", url: "https://changelog.com/podcast/feed" },
                { name: "Software Engineering Daily", url: "https://softwareengineeringdaily.com/feed/podcast/" },
                { name: "Syntax.fm", url: "https://feed.syntax.fm/rss" },
                { name: "Talk Python", url: "https://talkpython.fm/episodes/rss" },
            ],
            "Miscellaneous": [
                { name: "Wait But Why", url: "https://waitbutwhy.com/feed" },
                { name: "Brain Pickings", url: "https://www.themarginalian.org/feed/" },
                { name: "Kottke", url: "https://feeds.kottke.org/main" },
                { name: "Austin Kleon", url: "https://austinkleon.com/feed/" },
                { name: "Seth Godin", url: "https://seths.blog/feed/" },
                { name: "Longform", url: "https://longform.org/feed.rss" },
                { name: "The Browser", url: "https://thebrowser.com/feed/" },
                { name: "Farnam Street", url: "https://fs.blog/feed/" },
                { name: "XKCD", url: "https://xkcd.com/rss.xml" },
            ],
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Try to load from localStorage as backup
            const saved = localStorage.getItem('rssReaderState');
            if (saved) {
                try {
                    state = JSON.parse(saved);
                    renderFeeds();
                    showStatus('Loaded previous session from browser storage.', 'success');
                } catch (e) {}
            }
            renderSuggestions();
        });

        function showStatus(msg, type = 'loading') {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.className = `status ${type}`;
            el.classList.remove('hidden');
            if (type !== 'loading') {
                setTimeout(() => el.classList.add('hidden'), 3000);
            }
        }

        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        function saveToLocalStorage() {
            localStorage.setItem('rssReaderState', JSON.stringify(state));
        }

        // Suggestions panel
        function toggleSuggestions() {
            const content = document.getElementById('suggestionsContent');
            const toggle = document.getElementById('suggestionsToggle');
            content.classList.toggle('open');
            toggle.textContent = content.classList.contains('open') ? 'â–¼ Hide' : 'â–¶ Show';
        }

        function renderSuggestions() {
            const container = document.getElementById('suggestionsContent');
            container.innerHTML = Object.entries(FEED_SUGGESTIONS).map(([category, feeds]) => `
                <div class="suggestions-category">
                    <h3>${category}</h3>
                    <div>
                        ${feeds.map(feed => {
                            const isAdded = state.feeds.some(f => f.url === feed.url);
                            return `<span class="suggestion-item ${isAdded ? 'added' : ''}"
                                         onclick="addSuggestion('${escapeHtml(feed.url)}', '${escapeHtml(feed.name)}')"
                                         title="${escapeHtml(feed.url)}">
                                ${isAdded ? 'âœ“' : '+'} ${escapeHtml(feed.name)}
                            </span>`;
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        function addSuggestion(url, name) {
            if (state.feeds.some(f => f.url === url)) {
                showStatus('Feed already added!', 'error');
                return;
            }
            state.feeds.push({ url, title: name });
            renderFeeds();
            renderSuggestions();
            saveToLocalStorage();
            showStatus(`Added "${name}". Click Refresh All to load.`, 'success');
        }

        // Feed management
        function addFeed() {
            const input = document.getElementById('feedUrl');
            const url = input.value.trim();
            if (!url) return;

            if (state.feeds.some(f => f.url === url)) {
                showStatus('Feed already exists!', 'error');
                return;
            }

            state.feeds.push({ url, title: url });
            input.value = '';
            renderFeeds();
            renderSuggestions();
            saveToLocalStorage();
            fetchFeed(url);
        }

        function removeFeed(url) {
            state.feeds = state.feeds.filter(f => f.url !== url);
            allItems = allItems.filter(item => item.feedUrl !== url);
            renderFeeds();
            renderSuggestions();
            renderItems();
            saveToLocalStorage();
        }

        function renderFeeds() {
            const container = document.getElementById('feedsList');
            if (state.feeds.length === 0) {
                container.innerHTML = 'No feeds yet. Add one above or import a state file.';
                return;
            }
            container.innerHTML = state.feeds.map(f => `
                <span class="feed-tag">
                    ${escapeHtml(f.title || f.url)}
                    <button onclick="removeFeed('${escapeHtml(f.url)}')">&times;</button>
                </span>
            `).join('');
        }

        // Fetching
        async function fetchFeed(url) {
            try {
                const response = await fetch(CORS_PROXY + encodeURIComponent(url));
                if (!response.ok) throw new Error('Fetch failed');

                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');

                // Check for parse errors
                const parseError = xml.querySelector('parsererror');
                if (parseError) throw new Error('Invalid RSS/XML');

                // Handle RSS 2.0
                let items = Array.from(xml.querySelectorAll('item'));
                let feedTitle = xml.querySelector('channel > title')?.textContent;

                // Handle Atom
                if (items.length === 0) {
                    items = Array.from(xml.querySelectorAll('entry'));
                    feedTitle = xml.querySelector('feed > title')?.textContent;
                }

                // Update feed title
                const feedIndex = state.feeds.findIndex(f => f.url === url);
                if (feedIndex >= 0 && feedTitle) {
                    state.feeds[feedIndex].title = feedTitle;
                    renderFeeds();
                    saveToLocalStorage();
                }

                // Parse items
                const parsed = items.map(item => {
                    // RSS 2.0
                    let title = item.querySelector('title')?.textContent;
                    let link = item.querySelector('link')?.textContent;
                    let desc = item.querySelector('description')?.textContent;
                    let date = item.querySelector('pubDate')?.textContent;
                    let guid = item.querySelector('guid')?.textContent;

                    // Atom fallbacks
                    if (!link) {
                        const linkEl = item.querySelector('link[href]');
                        link = linkEl?.getAttribute('href');
                    }
                    if (!desc) desc = item.querySelector('summary')?.textContent || item.querySelector('content')?.textContent;
                    if (!date) date = item.querySelector('published')?.textContent || item.querySelector('updated')?.textContent;
                    if (!guid) guid = item.querySelector('id')?.textContent;

                    const id = guid || link || title;

                    return {
                        id,
                        title: title || 'Untitled',
                        link,
                        description: stripHtml(desc || '').slice(0, 300),
                        date: date ? new Date(date) : null,
                        feedUrl: url,
                        feedTitle: feedTitle || url,
                        read: state.readItems.includes(id)
                    };
                });

                // Merge with existing items (avoid duplicates)
                const existingIds = new Set(allItems.map(i => i.id));
                const newItems = parsed.filter(i => !existingIds.has(i.id));
                allItems = [...allItems, ...newItems];

                return parsed.length;
            } catch (e) {
                console.error('Error fetching', url, e);
                throw e;
            }
        }

        async function refreshAll() {
            if (state.feeds.length === 0) {
                showStatus('No feeds to refresh. Add some first!', 'error');
                return;
            }

            showStatus(`Fetching ${state.feeds.length} feed(s) in parallel...`);
            allItems = [];

            // Fetch all feeds in parallel
            const results = await Promise.allSettled(
                state.feeds.map(feed => fetchFeed(feed.url))
            );

            const success = results.filter(r => r.status === 'fulfilled').length;
            const failed = results.filter(r => r.status === 'rejected').length;

            state.lastUpdated = new Date().toISOString();
            saveToLocalStorage();

            // Sort by date, newest first
            allItems.sort((a, b) => {
                if (!a.date) return 1;
                if (!b.date) return -1;
                return b.date - a.date;
            });

            renderItems();

            if (failed > 0) {
                showStatus(`Loaded ${success} feed(s), ${failed} failed.`, 'error');
            } else {
                showStatus(`Loaded ${allItems.length} items from ${success} feed(s).`, 'success');
            }
        }

        // Rendering items
        function renderItems() {
            const container = document.getElementById('itemsContainer');
            const showRead = document.getElementById('showReadToggle').checked;
            const unreadCount = allItems.filter(i => !i.read).length;
            const displayItems = showRead ? allItems : allItems.filter(i => !i.read);

            document.getElementById('statsText').textContent =
                `${allItems.length} items total, ${unreadCount} unread`;

            if (displayItems.length === 0) {
                if (allItems.length === 0) {
                    container.innerHTML = '<div class="item" style="color: #888; text-align: center;">No items. Add feeds and refresh.</div>';
                } else {
                    container.innerHTML = '<div class="item" style="color: #888; text-align: center;">All caught up! No unread items.</div>';
                }
                return;
            }

            container.innerHTML = displayItems.map((item) => {
                const idx = allItems.indexOf(item);
                return `
                <div class="item ${item.read ? 'read' : ''}" data-idx="${idx}">
                    <div class="item-header">
                        <div>
                            <a href="${escapeHtml(item.link || '#')}" target="_blank" class="item-title"
                               onclick="markRead(${idx})">${escapeHtml(item.title)}</a>
                            <div class="item-meta">
                                ${escapeHtml(item.feedTitle)}
                                ${item.date ? 'â€¢ ' + formatDate(item.date) : ''}
                            </div>
                        </div>
                        <button class="mark-read-btn" onclick="toggleRead(${idx})">
                            ${item.read ? 'Mark unread' : 'Mark read'}
                        </button>
                    </div>
                    ${item.description ? `<div class="item-desc">${escapeHtml(item.description)}${item.description.length >= 300 ? '...' : ''}</div>` : ''}
                </div>
            `}).join('');
        }

        function markRead(idx) {
            const item = allItems[idx];
            if (!item.read) {
                item.read = true;
                if (!state.readItems.includes(item.id)) {
                    state.readItems.push(item.id);
                    saveToLocalStorage();
                }
                renderItems();
            }
        }

        function toggleRead(idx) {
            const item = allItems[idx];
            item.read = !item.read;

            if (item.read) {
                if (!state.readItems.includes(item.id)) {
                    state.readItems.push(item.id);
                }
            } else {
                state.readItems = state.readItems.filter(id => id !== item.id);
            }

            saveToLocalStorage();
            renderItems();
        }

        function markAllRead() {
            allItems.forEach(item => {
                item.read = true;
                if (!state.readItems.includes(item.id)) {
                    state.readItems.push(item.id);
                }
            });
            saveToLocalStorage();
            renderItems();
            showStatus('All items marked as read.', 'success');
        }

        // Import/Export
        function exportState() {
            const data = JSON.stringify(state, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rss-state-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showStatus('State exported!', 'success');
        }

        function importState(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Validate structure
                    if (!Array.isArray(imported.feeds)) {
                        throw new Error('Invalid state file: missing feeds array');
                    }

                    state = {
                        feeds: imported.feeds || [],
                        readItems: imported.readItems || [],
                        lastUpdated: imported.lastUpdated || null
                    };

                    allItems = [];
                    renderFeeds();
                    renderSuggestions();
                    saveToLocalStorage();
                    showStatus(`Imported ${state.feeds.length} feed(s). Click "Refresh All" to load articles.`, 'success');
                } catch (err) {
                    showStatus('Failed to import: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset for re-import
        }

        // Utilities
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/[&<>"']/g, m => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
            })[m]);
        }

        function stripHtml(html) {
            const tmp = document.createElement('div');
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || '';
        }

        function formatDate(date) {
            const now = new Date();
            const diff = now - date;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));

            if (days === 0) {
                const hours = Math.floor(diff / (1000 * 60 * 60));
                if (hours === 0) {
                    const mins = Math.floor(diff / (1000 * 60));
                    return mins <= 1 ? 'just now' : `${mins}m ago`;
                }
                return `${hours}h ago`;
            } else if (days === 1) {
                return 'yesterday';
            } else if (days < 7) {
                return `${days}d ago`;
            }
            return date.toLocaleDateString();
        }
    </script>
</body>
</html>
